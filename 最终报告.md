# C语言实验-酒店预订管理系统
## 功能说明及任务
- 管理员
    - [x] 基本信息管理
        - [x] 客房
    		- [x] 增加
			<details>
        	<summary><mark><font color=darkred>点击查看详细内容</font></mark></summary>
			
			```c
			void add_room_type()
			{
				TYPE_ROOM* head = read_from_file(data_filename);
				TYPE_ROOM* curr = head;
				while (curr->next!=NULL)
					curr = curr->next;
				TYPE_ROOM* new = (TYPE_ROOM*)malloc(sizeof(TYPE_ROOM));
				curr->next = new;
				new->room = NULL;
				new->next = NULL;
				int num;
				float size;
				char typename[100];
				int ID;
				double price;
				char status[20];
				char location[20];
				printf("输入该类型房间数量，大小以及类型名,英文逗号相隔：");
				scanf("%d,%f,%[^,\n]", &num, &size, typename);
				new->num = num;
				new->size = size;
				strcpy(new->typename, typename);
				printf("依次输入该类型下各房间信息（包含房间号，价格，状态，位置）,英文逗号相隔:");
				for (int i = 0; i < num; i++)
				{
					scanf("%d,%lf,%[^,],%[^,\n]", &ID, &price, status, location);
					new->room = single_connect(new->room, ID, price, status, location);
				}
				printf("修改成功\n");
				write_to_file(head, "D:\\code\\vs2022\\c语言实验设计\\data.txt");
			}
			```
        	</details>

			- [x] 删除
			<details>
        	<summary><mark><font color=darkred>点击查看详细内容</font></mark></summary>

			```c
			void delete_room_type()
			{
				TYPE_ROOM* head = read_from_file(data_filename);
				TYPE_ROOM* curr = head;
				int ID;
				printf("请输入要删除的房间ID：");
				scanf("%d", &ID);
				int found = 0;
				while (curr)
				{
					curr->room = deletesingle(curr->room, ID);
					curr = curr->next;
				}
				write_to_file(head, data_filename);
			}
			```
        	</details>

			- [x] 修改
			<details>
        	<summary><mark><font color=darkred>点击查看详细内容</font></mark></summary>

			```c
			void adjust_information_room()
			{
				TYPE_ROOM* head = read_from_file(data_filename);
				int ID;
				int found = 0;
				printf("请输入待修改房间号：");
				scanf("%d", &ID);
				TYPE_ROOM* curr = head;
				Single_room* roomcurr;
				while (curr)
				{
					roomcurr = curr->room;
					while (roomcurr != NULL && roomcurr->ID != ID)
						roomcurr = roomcurr->next;
					if (roomcurr != NULL)
					{
						found = 1;
						break;
					}
					curr = curr->next;
				}
				printf("输入该房间各项信息（包括房间号，价格，状态，位置）：");
				double price;
				char status[20];
				char location[20];
				scanf("%d,%lf,%[^,],%[^,\n]", &ID, &price, status, location);
				roomcurr->ID = ID;
				roomcurr->price = price;
				roomcurr->status = convert_status_room(status);
				roomcurr->location = convert_location(location);
				write_to_file(head, data_filename);
				printf("修改成功！\n");
			}
			```
        	</details>

        - [x] 客人
    		- [x] 增加
			<details>
        	<summary><mark><font color=darkred>点击查看详细内容</font></mark></summary>

			```c
			void add_cus()
			{
				CUSTOMER* head = read_from_cusdatafile(cus_data_filename);
				CUSTOMER* curr = head;
				int number;
				char ID[19];
				char name[20];
				char vip_level[20];
				printf("请输入客人相关信息（包括人数，身份证，姓名，VIP等级）");
				scanf("%d,%[^,],%[^,],%[^,\n]", &number, ID, name, vip_level);
				while (curr->next!=NULL)
				{
					curr = curr->next;
				}
				CUSTOMER* new = (CUSTOMER*)malloc(sizeof(CUSTOMER));
				curr->next = new;
				new->number = number;
				strcpy(new->ID, ID);
				strcpy(new->name, name);
				new->vip_level = convert_vip_level(vip_level);
				new->next = NULL;
				write_to_cusdatafile(head, cus_data_filename);
			}
			```
			</details>
			
			- [x] 删除
			<details>
        	<summary><mark><font color=darkred>点击查看详细内容</font></mark></summary>

			```c
			void delete_customer_type()
			{
				CUSTOMER* head = read_from_cusdatafile(cus_data_filename);
				CUSTOMER* curr = head, * prev = NULL;
				char ID[19];
				printf("输入删除客人的身份证号：");
				scanf("%s", ID);
				while (curr != NULL && strcmp(curr->ID, ID) != 0)
				{
					prev = curr;
					curr = curr->next;
				}
				if (prev == NULL)
				{
					head = head->next;
				}
				else
				{
					prev->next = curr->next; 
					printf("删除成功\n");
					write_to_cusdatafile(head, cus_data_filename);
					return;
				}	
				printf("删除失败\n");
				write_to_cusdatafile(head, cus_data_filename);
			}
			```
        	</details>
 
			- [x] 修改
			<details>
        	<summary><mark><font color=darkred>点击查看详细内容</font></mark></summary>

			```c
			void adjust_information_cus()
			{
				CUSTOMER* head = read_from_cusdatafile(cus_data_filename);
				char ID[19];
				printf("输入待调整客户身份证号：");
				scanf("%s", ID);
				CUSTOMER* curr = head;
				while (curr != NULL && strcmp(curr->ID, ID) != 0)
				{
					curr = curr->next;
				}
				if (curr == NULL)
				{
					printf("查找失败\n");
					return;
				}
				int number;
				char name[20];
				char vip_level[20];
				printf("输入客户信息（包括人数，身份证号，姓名，vip等级）(英文逗号相隔)：");
				scanf("%d,%[^,],%[^,],%[^,\n]", &number, ID, name, vip_level);
				curr->number = number;
				strcpy(curr->ID, ID);
				strcpy(curr->name, name);
				curr->vip_level = convert_vip_level(vip_level);
				write_to_cusdatafile(head,cus_data_filename);
				printf("修改成功\n");
			}
			```
        	</details>

    - [x] 信息设置管理
        - [x] 调整房间类型
    		<details>
        	<summary><mark><font color=darkred>点击查看详细内容</font></mark></summary>
			
			```c
			void adjust_room_type()
			{
				TYPE_ROOM* head = read_from_file(data_filename);
				TYPE_ROOM* curr = head, *prev = NULL;
				Single_room* roomcurr;
				Single_room* roomprev = NULL;
				int ID;
				int found = 0;
				printf("输入待调整房间号：");
				scanf("%d", &ID);
				while (curr)
				{
					roomcurr = curr->room;
					roomprev = NULL;
					while (roomcurr)
					{
						if (roomcurr->ID == ID)
						{
							found = 1;
							break; 
						}
						roomprev = roomcurr;
						roomcurr = roomcurr->next;
					}
					if (found)
					{
						if (roomprev == NULL)
							curr->room = roomcurr->next;
						else
							roomprev->next = roomcurr->next;
						break;
					}
					prev = curr;
					curr = curr->next;
				}
				if (!found)
				{
					printf("查找房间失败，即将返回主菜单\n");
					return;
				}
				char typename[20];
				printf("输入新类型\n");
				scanf("%s", typename);
				curr = head;
				while (curr)
				{
					if (strcmp(curr->typename, typename) == 0)
					{
						if (curr->room == NULL)
							curr->room = roomcurr;
						else
						{
							Single_room* now = curr->room;
							while (now->next)
								now = now->next;
							now->next = roomcurr;
						}
						roomcurr->next = NULL;
						break;
					}
					curr = curr->next;
				}
				printf("%d房间类型已修改为%s\n", ID, typename);
				write_to_file(head, data_filename);
			}
			```
        	</details>

        - [x] 调整客人类型
    		<details>
        	<summary><mark><font color=darkred>点击查看详细内容</font></mark></summary>
			
			```c
			void adjust_cus_type()
			{
				char ID[19];
				printf("输入客人身份证号：");
				scanf("%s", ID);
				CUSTOMER* head = read_from_cusdatafile(cus_data_filename);
				CUSTOMER* curr = head;
				while (curr)
				{
					if (strcmp(curr->ID,ID)==0)
						break;
					curr = curr->next;
				}
				if (curr == NULL)
				{
					printf("寻找客人失败\n");
					return;
				}
				else
				{
					char newlevel[20];
					printf("输入客人VIP等级：");
					scanf("%s", newlevel);
					curr->vip_level= convert_vip_level(newlevel);
					printf("修改成功\n");
					write_to_cusdatafile(head, cus_data_filename);
					return;
				}
			}
			```
        	</details>

        - [x] 设置房间价格
    		<details>
        	<summary><mark><font color=darkred>点击查看详细内容</font></mark></summary>

			```c
        	void adjust_room_price()
			{
				char condition[20];
				printf("输入当前情况（cold season/hot season/weekend/weekday）：");
				getchar();
				scanf("%[^\n]", condition);
				TYPE_ROOM* head = read_from_file(data_filename);
				int ID;
				printf("请输入房间编号：");
				scanf("%d", &ID);
				TYPE_ROOM* curr = head;
				int found = 0;
				while (curr)
				{
					Single_room* single_curr = curr->room;
					while (single_curr)
					{
						if (single_curr->ID == ID)
						{
							found = 1;
							if (strcmp(condition, "cold season") == 0)
							{
								single_curr->price *= 0.85;
							}
							else if (strcmp(condition, "hot season") == 0)
							{
								single_curr->price *= 1.85;
			
							}
							else if (strcmp(condition, "weekend") == 0)
							{
								single_curr->price *= 1.85;
							}
							else if (strcmp(condition, "weekday") == 0)
							{
								single_curr->price *= 0.85;
							}
							else
							{
								printf("输入无效\n");
								return;
							}
							printf("房间%d的价格已调整为新价格：%.2lf\n", ID, single_curr->price);
							break;
						}
						single_curr = single_curr->next;
					}
					if (found)
						break;
					curr = curr->next;
				}
				if (!found)
				{
					printf("房间查找失败\n");
					return;
				}
				write_to_file(head, data_filename);
				return;
			}
			```
			</details>

        - [x] 设置折扣程度
    		<details>
        	<summary><mark><font color=darkred>点击查看详细内容</font></mark></summary>

			```c
			void adjust_vip_discount()
			{
				set_vip_discount();
				read_vip_discount();
			}
			void read_vip_discount()
			{
				FILE* fp = fopen("D:\\code\\vs2022\\c语言实验设计\\vip_discount.txt","r");
				if (fp == NULL)
				{
					printf("崩溃啦！\n");
					return;
				}
				fscanf(fp, "%lf,%lf,%lf,%lf", &vip_discounts[0], &vip_discounts[1], &vip_discounts[2], &vip_discounts[3]);
				fclose(fp);
			}
			
			void set_vip_discount()
			{
				FILE* fp = fopen("D:\\code\\vs2022\\c语言实验设计\\vip_discount.txt", "w");
				double new_discount[4] = { 0 };
				printf("依次输入vip等级对应折扣(空格相隔)：");
				for (int i = 0; i < 4; i++)
				{
					scanf("%lf", &new_discount[i]);
					fprintf(fp, "%.2lf,", new_discount[i]);
				}
				fclose(fp);
			}
    		```
        	</details>

    - [ ] 信息查询
        - [x] 简单查询
    		- [x] 客房
    			- 房间号
				<details>
            	<summary><mark><font color=darkred>点击查看详细内容</font></mark></summary>

				```c
				void simple_search_room()
				{
					TYPE_ROOM* head = read_from_file(data_filename);
					TYPE_ROOM* curr = head;
					printf("输入待查询房间ID:\n");
					int ID;
					int found = 0;
					scanf("%d", &ID);
					while (curr)
					{
						Single_room* roomcurr = curr->room;
						while (roomcurr)
						{
							if (roomcurr->ID == ID)
							{
								print_singleroom(roomcurr);
								found = 1;
								break;
							}
							roomcurr = roomcurr->next;
						}
						if (found == 1)
							break;
						curr = curr->next;
					}
					if (found == 0)
						printf("未查询到房间号为%d的房间", ID);
				}
				```
            	</details>

				- 类型
				<details>
            	<summary><mark><font color=darkred>点击查看详细内容</font></mark></summary>

				```c
            	</details>

			- [x] 客人
    			- 身份证号

				- 姓名
				<details>
            	<summary><mark><font color=darkred>点击查看详细内容</font></mark></summary>

				```c
            	void simple_search_cus()
				{
					CUSTOMER* head = read_from_cusdatafile(cus_data_filename);
					CUSTOMER* curr = head;
					printf("1.身份证号\n");
					printf("2.姓名\n");
					int choice;
					int found = 0;
					scanf("%d", &choice);
					if (choice == 1)
					{
						printf("请输入身份证号:");
						char ID[19];
						scanf("%s", ID);
						while (curr)
						{
							if (strcmp(curr->ID, ID) == 0)
							{
								print_cus(curr);
								found = 1;
								break;
							}
							curr = curr->next;
						}
						if (!found)
							printf("查询失败\n");
					}
					else if (choice == 2)
					{
						printf("请输入姓名:");
						char name[19];
						scanf("%s", name);
						while (curr)
						{
							if (strcmp(curr->name, name) == 0)
							{
								print_cus(curr);
								found = 1;
								break;
							}
							curr = curr->next;
						}
						if (!found)
							printf("查询失败\n");
					}
					else
					{
						printf("输入错误,即将返回主菜单\n");
						return;
					}
				}
				```
				</details>

        - [x] 组合查询
    		- [x] 客房
    			- 房间状态与房间位置

				- 房间价格与房间状态
				<details>
            	<summary><mark><font color=darkred>点击查看详细内容</font></mark></summary>

				```c
				void teamsearch_room()
				{
					TYPE_ROOM* head = read_from_file(data_filename);
					TYPE_ROOM* curr = head;
					printf("1.房间状态与房间位置\n");
					printf("2.房间状态与房间价格\n");
					int choice;
					char status[20], location[20];
					double price;
					int found = 0;
					scanf("%d", &choice);
					if (choice == 1)
					{
						printf("请输入房间状态与房间位置(英文逗号分隔):");
						scanf("%[^,],%[^,\n]", status, location);
						while (curr)
						{
							Single_room* roomcurr = curr->room;
							while (roomcurr)
							{
								if (roomcurr->status == convert_status_room(status) && roomcurr->location == convert_location(location))
								{
									print_singleroom(roomcurr);
									found = 1;
									break;
								}
								roomcurr = roomcurr->next;
							}
							curr = curr->next;
						}
						if (!found)
							printf("查询失败\n");
					}
					else if (choice == 2)
					{
						printf("请输入房间状态与房间价格(英文逗号分隔):");
						scanf("%[^,],%lf", status, &price);
						while (curr)
						{
							Single_room* roomcurr = curr->room;
							while (roomcurr)
							{
								if (roomcurr->status == convert_status_room(status) && roomcurr->price == price)
								{
									print_singleroom(roomcurr);
									found = 1;
									break;
								}
								roomcurr = roomcurr->next;
							}
							curr = curr->next;
						}
						if (!found)
							printf("查询失败\n");
					}
					else
					{
						printf("输入错误,即将返回主菜单\n");
						return;
					}
				}
				```
            	</details>

			- [x] 客人
    			- 客人数量与VIP等级
				<details>
            	<summary><mark><font color=darkred>点击查看详细内容</font></mark></summary>

				```c
				void teamsearch_cus()
				{
					CUSTOMER* head = read_from_cusdatafile(cus_data_filename);
					CUSTOMER* curr = head;
					char vip[20];
					int num;
					int found = 0;
					printf("请输入客人数量与VIP等级(英文逗号分隔):");
					scanf("%d,%s", num, vip);
					while (curr)
					{
						if (curr->number=num&&curr->vip_level==convert_vip_level(vip))
						{
							print_cus(curr);
							found = 1;
							break;
						}
						curr = curr->next;
					}
					if (!found)
						printf("查询失败\n");
				}
				```
            	</details>

        - [x] 模糊查询
        	- [x] 客房
    			- 客房价格范围

				- 客房状态
				<details>
            	<summary><mark><font color=darkred>点击查看详细内容</font></mark></summary>

				```c
				Single_room* ambiguoussearch_room()
				{
					TYPE_ROOM* head = read_from_file(data_filename);
					TYPE_ROOM* curr = head;
					Single_room* newhead = NULL, * tail = NULL;
					printf("1.客房价格范围\n");
					printf("2.客房状态\n");
					int choice;
					char status[20];
					double price1,price2;
					int found = 0;
					scanf("%d", &choice);
					if (choice == 1)
					{
						printf("请输入房间价格区间(英文逗号分隔):");
						scanf("%d,%d", &price1, &price2);
						while (curr)
						{
							Single_room* roomcurr = curr->room;
							while (roomcurr)
							{
								if (roomcurr->price <= price2 && roomcurr->price >= price1)
								{
									if (newhead == NULL)
										newhead = roomcurr;
									else
										tail->next = roomcurr;
									print_singleroom(roomcurr);
									found = 1;
									tail = roomcurr;
								}
								roomcurr = roomcurr->next;
							}
							curr = curr->next;
						}
						if (!found)
							printf("查询失败\n");
						return newhead;
					}
					else if (choice == 2)
					{
						printf("请输入房间状态:");
						scanf("%s", status);
						while (curr)
						{
							Single_room* roomcurr = curr->room;
							while (roomcurr)
							{
								if (roomcurr->status == convert_status_room(status))
								{
									if (newhead == NULL)
										newhead = roomcurr;
									else
										tail->next = roomcurr;
									print_singleroom(roomcurr);
									found = 1;
									tail = roomcurr;
								}
								roomcurr = roomcurr->next;
							}
							curr = curr->next;
						}
						if (!found)
							printf("查询失败\n");
						tail->next = NULL;			//手动设置最后连接NULL,否则会将在后一个结点的后续一并算在链表里
						return newhead;
					}
					else
					{
						printf("输入错误,即将返回主菜单\n");
						return;
					}
				}
				```
            	</details>

			- [x] 客人
    			- 客人状态
				<details>
            	<summary><mark><font color=darkred>点击查看详细内容</font></mark></summary>

				```c
				Reservation* ambiguoussearch_reservation()
				{
					Reservation* head1 = read_from_reservation(reservation_filename);
					Reservation* curr1 = head1;
					Reservation* newhead=NULL;
					Reservation* tail;
					int found = 0;
					char status[20];
					printf("输入客人状态:");
					scanf("%s", status);
					while (curr1)
					{
						if (curr1->status == convert_status_cus(status))
						{
							if (newhead == NULL)
								newhead = curr1;
							else
								tail->next = curr1;
							print_reservation(curr1);
							found = 1;
							tail = curr1;
						}
						curr1 = curr1->next;
					}
					if (!found)
						printf("查询失败\n");
					tail->next = NULL;
					return newhead;
				}
				```
            	</details>

				- 客人vip等级
				<details>
                <summary><mark><font color=darkred>点击查看详细内容</font></mark></summary>

				```c
            	CUSTOMER* ambiguoussearch_cus()
				{
					CUSTOMER* head2 = read_from_cusdatafile(cus_data_filename);
					CUSTOMER* curr2 = head2;
					CUSTOMER* newhead = NULL, * tail = NULL;
					int found = 0;
					char vip[20];
					printf("输入客人vip等级:");
					scanf("%s", vip);
					while (curr2)
					{
						if (curr2->vip_level == convert_vip_level(vip))
						{
							if (newhead == NULL)
								newhead = curr2;
							else
								tail->next = curr2;
							found = 1;
							print_cus(curr2);
							tail = curr2;
						}
						curr2 = curr2->next;
					}
					if (!found)
						printf("查询失败\n");
					tail->next = NULL;
					return newhead;
				}
				```
				</details>

    - [x] 信息排序
        - [x] 单一属性
    		- [x] 客房
    			- 房间号

				- 价格
				<details>
            	<summary><mark><font color=darkred>点击查看详细内容</font></mark></summary>

				```c
                void singlesort_room(Single_room* head)
				{
					printf("1.按房间号排序\n");
					printf("2.按价格排序\n");
					int choice = 0;
					scanf("%d", &choice);
					if (choice == 1)
					{
						Single_room* sort = insertion_sort_single_room_ID(head);
						Single_room* curr = sort;
						while (curr)
						{
							print_singleroom(curr);
							curr = curr->next;
						}
					}
					else if (choice == 2)
					{
						Single_room* sort = insertion_sort_single_room_price(head);
						Single_room* curr = sort;
						while (curr)
						{
							print_singleroom(curr);
							curr = curr->next;
						}
					}
					else
					{
						printf("输入错误\n");
						return;
					}
				}
				```
				</details>

			- [x] 客人
    			- vip
				<details>
            	<summary><mark><font color=darkred>点击查看详细内容</font></mark></summary>

				```c
				void singlesort_cus(CUSTOMER* head)
				{
					printf("按vip等级排序\n");
					CUSTOMER* sort = insertion_sort_single_cus_vip(head);
					CUSTOMER* curr = sort;
					while (curr)
					{
						print_cus(curr);
						curr = curr->next;
					}
					return;
				}
				```
            	</details>

        - [x] 多属性
    		- [x] 客房
    			- 状态与价格
				<details>
            	<summary><mark><font color=darkred>点击查看详细内容</font></mark></summary>

				```c
				void complexsort_room()
				{
					Single_room* head = extract_from_typeroom(read_from_file(data_filename));
					printf("先按状态,再位置,后价格排序\n");
					Single_room* sort = insertion_sort_single_room_ID(head);
					Single_room* curr = sort;
					while (curr)
					{
						print_singleroom(curr);
						curr = curr->next;
					}
				}
				Single_room* insertion_sort_single_room_ID(Single_room* head)
				{
					if (head == NULL || head->next == NULL)
						return head;
					Single_room* sort = NULL;
					Single_room* curr = head;
					while (curr)
					{
						Single_room* next = curr->next;
						if (sort == NULL || sort->ID >= curr->ID)
						{
							curr->next = sort;
							sort = curr;
						}
						else
						{
							Single_room* temp = sort;
							while (temp->next != NULL && temp->next->ID < curr->ID)
								temp = temp->next;
							curr->next = temp->next;
							temp->next = curr;
						}
						curr = next;
					}
					return sort;
				}
				
				Single_room* insertion_sort_single_room_price(Single_room* head)
				{
					if (head == NULL || head->next == NULL)
						return head;
					Single_room* sort = NULL;
					Single_room* curr = head;
					while (curr)
					{
						Single_room* next = curr->next;
						if (sort == NULL || sort->price>= curr->price)
						{
							curr->next = sort;
							sort = curr;
						}
						else
						{
							Single_room* temp = sort;
							while (temp->next != NULL && temp->next->price < curr->price)
								temp = temp->next;
							curr->next = temp->next;
							temp->next = curr;
						}
						curr = next;
					}
					return sort;
				}
				```
            	</details>
		
        	- [x] 客人
    			- 入住时间与退房时间
				<details>
            	<summary><mark><font color=darkred>点击查看详细内容</font></mark></summary>

				```c
				void complex_reservation()
				{
					Reservation* head = read_from_reservation(reservation_filename);
					printf("先按入住时间,后退房时间\n");
					Reservation* sort = insertion_sort_checkin_checkout(head);
					Reservation* curr = sort;
					while (curr)
					{
						print_reservation(curr);
						curr = curr->next;
					}
				}
				CUSTOMER* insertion_sort_single_cus_vip(CUSTOMER* head)
				{
					if (head == NULL || head->next == NULL)
						return head;
					CUSTOMER* sort = NULL;
					CUSTOMER* curr = head;
					while (curr)
					{
						CUSTOMER* next = curr->next;
						if (sort == NULL || sort->vip_level >= curr->vip_level)
						{
							curr->next = sort;
							sort = curr;
						}
						else
						{
							CUSTOMER* temp = sort;
							while (temp->next != NULL && temp->next->vip_level < curr->vip_level)
								temp = temp->next;
							curr->next = temp->next;
							temp->next = curr;
						}
						curr = next;
					}
					return sort;
				}
				```
            	</details>

  - [x] 信息统计
      - [x] 单一属性
    	- [x] 客房
        	- 状态

			- 位置
				<details>
               	<summary><mark><font color=darkred>点击查看详细内容</font></mark></summary>

				```c
				void single_stat_room()
				{
					int stat = 0;
					Single_room* head = extract_from_typeroom(read_from_file(data_filename));
					Single_room* curr = head;
					printf("请输入待统计数据:\n");
					printf("1.状态\n");
					printf("2.位置\n");
					int choice = 0;
					scanf("%d", &choice);
					if (choice == 1)
					{
						char status[20];
						printf("输入待统计状态:");
						scanf("%s", status);
						while (curr)
						{
							if (curr->status == convert_status_room(status))
								stat++;
							curr = curr->next;
						}
						printf("%s状态的客房有%d间\n", status, stat);
					}
					else if (choice == 2)
					{
						char location[20];
						printf("输入待统计位置:");
						scanf("%s", location);
						while (curr)
						{
							if (curr->status == convert_location(location))
								stat++;
							curr = curr->next;
						}
						printf("%s位置的客房有%d间\n", location, stat);
					}
				}
				```
            	</details>
			
		- [x] 客人
    		- 状态
				
			- vip
				
			- 入住时间
				<details>
            	<summary><mark><font color=darkred>点击查看详细内容</font></mark></summary>

				```c
				void single_stat_cus()
				{
					int stat = 0;
					printf("请输入待统计数据:\n");
					printf("1.状态\n");
					printf("2.vip\n");
					printf("3.入住时长\n");
					int choice = 0;
					scanf("%d", &choice);
					if (choice == 1)
					{
						Reservation* head = read_from_reservation(reservation_filename);
						Reservation* curr = head;
						char status[20];
						printf("输入待统计状态:");
						scanf("%s", status);
						while (curr)
						{
							if (curr->status == convert_status_cus(status))
								stat++;
							curr = curr->next;
						}
						printf("%s状态的客人有%d个\n", status, stat);
					}
					else if (choice == 2)
					{
						CUSTOMER* head = read_from_cusdatafile(cus_data_filename);
						CUSTOMER* curr;
						char vip[20];
						printf("输入待统计vip等级:");
						scanf("%s", vip);
						while (curr)
						{
							if (curr->vip_level == convert_vip_level(vip))
								stat++;
							curr = curr->next;
						}
						printf("%s等级的客人有%d个\n", vip, stat);
					}
					else if (choice == 3)
					{
						Reservation* head = read_from_reservation(reservation_filename);
						Reservation* curr = head;
						printf("输入待统计客人身份证号:");
						char ID[19];
						scanf("%s", ID);
						while (curr)
						{
							if (strcmp(curr->guest_id, ID) == 0)
							{
								stat = time_minus(curr->check_out, curr->check_in);
							}
							curr = curr->next;
						}
						printf("该客人入住时长为%d\n", stat);
					}
				}
				```
            	</details>

    - [ ] 多属性
       - [x] 客房
        	- 状态与位置
				<details>
            	<summary><mark><font color=darkred>点击查看详细内容</font></mark></summary>

				```c
				void complex_stat_room()
				{
					Single_room* head = extract_from_typeroom(read_from_file(data_filename));
					Single_room* curr = head;
					printf("输入客房状态与位置(英文逗号相隔):");
					char status[20], location[20];
					scanf("%[^,],%[^,\n]", status, location);
					int stat = 0;
					while (curr)
					{
						if (curr->status == convert_status_room(status) && curr->location == convert_location(location))
							stat++;
						curr = curr->next;
					}
					printf("%s状态且%s位置的客房有%d间\n", status, location, stat);
				}
				```
            	</details>
		
       - [ ] 客人
    		- 入住时间
				<details>
            	<summary><mark><font color=darkred>点击查看详细内容</font></mark></summary>

				```c
				void complex_stat_cus()
				{
					printf("不知道统计啥\n");
				}
				```
            	</details>
        
	- [x] 预设统计
            >之前写的全是预设统计,给出固定选项让用户选择
    - [ ] 条件统计

   - [ ] 系统维护
       - [x] 重置密码
    		<details>
        	<summary><mark><font color=darkred>点击查看详细内容</font></mark></summary>

			```c
        	</details>
      - [x] 找回密码
    		<details>
        	<summary><mark><font color=darkred>点击查看详细内容</font></mark></summary>

			```c
        	</details>
      - [ ] 数据备份
      - [ ] 数据恢复
- 前台
    -[ ]

- 客人
    -[ ]
---
### 前端账户注册登录
需要有一个txt文件存储所有人的账密信息,即member.txt 需要一个函数能够从该文件中读取信息
```c
MEMBER* member_data(const char* filename)
{
	FILE* fp;
	if ((fp = fopen(filename, "r")) == NULL)		//注意=与==的优先级，不加括号会将fopen(filename, "r") == NULL的结果赋给fp导致无法正常打开文件
	{
		printf("Failed to open the file");
		exit(0);
	}
	MEMBER* head = NULL, * tail = NULL;
	char account[20];
	char password[20];
	while (fscanf(fp, "%[^,],%[^,\n]\n",account,password) == 2)			//%[^,] 意为自由读取直到遇到','(不读取逗号)  然后跳过逗号  [^,\n]因为在读取最后一个数时会读入\n，也要跳过
	{
		MEMBER* new = (MEMBER*)malloc(sizeof(MEMBER));
		strcpy(new->account, account);
		strcpy(new->password, password);
		if (head == NULL)
		{
			head = new;
			head->next = NULL;
			tail = new;
		}
		else
		{
			tail->next = new;
			tail = new;
		}
	}
	tail->next = NULL;
	fclose(fp);
	return head;
}
```
>该函数返回一个头指针,指向一个存放了账密信息的链表,方便检查用户是否存在账号或者是否登陆成功

有了读取文件的函数,自然也需要一个函数来将程序运行中修改的数据体现在文件上,于是有了写入函数
```c
void member_write_to_file(const char* filename, char* account, char* password)
{
	FILE* fp = fopen(filename, "a+");		
	if (fp == NULL)
	{
		printf("Open failed\n");
		return;		//void型return后不加0
	}
	fprintf(fp, "%s,%s\n", account, password);
	printf("注册成功！\n");
	fclose(fp);
}
```
>这个函数无返回值,其作用是将链表中的信息依次写入到文件中实现文件的更新

登陆首先要注册一个账号,利用regist_member函数,让用户输入账号密码再将其写入文件实现注册
```c
void regist_member()
{
	FILE* fp;
	if ((fp = fopen("D:\\code\\vs2022\\c语言实验设计\\manager.txt", "a+")) == NULL)
	{
		printf("系统崩溃啦!");
		return 0;
	}
	char hide;
	int i = 0;
	char acc[20];
	char pas[20];
	printf("请输入账号：");
	scanf("%s", acc);
	printf("请输入密码：");
	while (1)
	{
		hide = getch();
		if (hide == 13)//13对应"\r" 回车
		{
			pas[i] = '\0';
			break;
		}
		else if (hide == 8 && i > 0)//ascii 8对应"\b"退格
		{
			i--;
			printf("\b \b");
		}
		else if (i < 20)
		{
			pas[i] = hide;
			i++;
			printf("*");
		}
	}
	printf("\n");
	member_write_to_file("D:\\code\\vs2022\\c语言实验设计\\member.txt", acc, pas);
}
```

注册完账号,就要开始登陆系统,由以下两个函数构成
```c
int ifcorrect(MEMBER* head,char *account,char *password)
{
	MEMBER* curr = head;
	while (curr)
	{
		if (strcmp(curr->account, account) == 0)
		{
			if (strcmp(curr->password, password) == 0)
			{
				return 1;
			}
		}
		curr = curr->next;
	}
	printf("登陆失败\n");
	return 0;
}
```
>判断输入的账号密码是否对应
```c
int log_in_member()
{
	MEMBER* head = member_data("D:\\code\\vs2022\\c语言实验设计\\member.txt");
	char account[20];
	char password[20];
	char hide;
	int i = 0;
	printf("请输入账号:");
	scanf("%20s", account);
	printf("是否显示密码:\n");
	printf("0.显示\n");
	printf("1.不显示\n");
	int ifdisplay;
	scanf("%d", &ifdisplay);
	if (ifdisplay)
	{
		printf("请输入密码:");
		while (1)
		{
			hide = getch();
			if (hide == 13)//13对应"\r" 回车
			{
				password[i] = '\0';
				break;
			}
			else if (hide == 8 && i > 0)//ascii 8对应"\b"退格
			{
				i--;
				printf("\b \b");
			}
			else if (i < 20)
			{
				password[i] = hide;
				i++;
				printf("*");
			}
		}
		printf("\n");
	}
	else
	{
		printf("请输入密码:");
		scanf("%s", password);
	}
	
	if (ifcorrect(head, account, password))
	{
		printf("登陆成功！\n");
		return 1;
	}
	else
		return 0;
}
```
>输入0或1,让用户自行选择是否隐藏密码,

以上为登陆系统的相关代码,诸如更改密码等操作在三种身份的系统维护中均有介绍

----
### 结构体与枚举变量的声明
- 枚举变量
    >枚举变量在该系统中十分常见,如客户vip等级,房间状态等,同时也能一定程度简化代码
	
	- 房间位置
	```c
	enum LOCATION
	{
		north,
		south,
		near_lift,
		near_corner
	};
	```
	- VIP等级
	```c
	enum VIP_LEVEL
	{
		black,
		gold,
		silver,
		common,
	};
	```
	- 客人状态
	```c
	enum STATUS_CUS
	{
		CUS_available,
    	CUS_reserved,
    	living,
    	leave,
	};
	```
	- 房间状态
	```c
	enum STATUS_ROOM
	{
    	ROOM_available,
    	ROOM_reserved,
    	check_in,
	};
	```
- 结构体
	>结构体分为三种,两种关于房间,一种关于客人,房间分为不同类型,不同类型下有不同房间,因此采用结构体嵌套定义
	- 单个房间

	```c
	typedef struct Single_room
	{
		int ID;
		double price;
		enum STATUS_ROOM status;
		enum LOCATION location;
		struct Single_room* next;
	}Single_room;
	```
	- 房间类型
	```c
	typedef struct TYPE_ROOM
	{
		int num;
		float size;
		char typename[100];
		Single_room* room;
		struct TYPE_ROOM* next;
	}TYPE_ROOM;
	```
	> 在TYPE_ROOM和Single_room中都留有一个next指针,因为要动态添加新的类型与新的房间,在运用时需要大链表套小链表
	- 客人
	```c
	typedef struct CUSTOMER
	{
		int number;
		char ID[19];
		char name[20];
		enum VIP_LEVEL vip_level;
		struct CUSTOMER* next;
	}CUSTOMER;
	```
----
### 枚举变量与字符串
#### 字符串转换为枚举变量

为了方便管理员直观的理解所有枚举变量的含义,我们选择直接输入字符串,而后将其转换为枚举变量,为此需要一系列函数将输入转换为枚举变量.

- 房间位置
```c
enum LOCATION convert_location(char* str)
{
	if (strcmp(str, "north") == 0)
	{
		return north;
	}
	else if (strcmp(str, "south") == 0)
	{
		return south;
	}
	else if (strcmp(str, "near_lift") == 0)
	{
		return near_lift;
	}
	else if (strcmp(str, "near_corner") == 0)
	{
		return near_corner;
	}
}
```
- VIP等级
```c
enum VIP_LEVEL convert_vip_level(char* str)
{
	if (strcmp(str, "black") == 0)
	{
		return black;
	}
	else if (strcmp(str, "gold") == 0)
	{
		return gold;
	}
	else if (strcmp(str, "silver") == 0)
	{
		return silver;
	}
	else if (strcmp(str, "common") == 0)
	{
		return common;
	}
}
```
- 客人状态
```c
enum STATUS_CUS convert_status_cus(char* str)
{
	if (strcmp(str, "CUS_available") == 0)
	{
		return CUS_available;
	}
	else if (strcmp(str, "CUS_reserved") == 0)
	{
		return CUS_reserved;
	}
	else if (strcmp(str, "living") == 0)
	{
		return living;
	}
	else if (strcmp(str, "leave") == 0)
	{
		return leave;
	}
}
```
- 房间状态
```c
enum STATUS_ROOM convert_status_room(char* str)
{
	if (strcmp(str, "ROOM_available") == 0)
	{
		return ROOM_available;
	}
	else if (strcmp(str, "ROOM_reserved") == 0)
	{
		return ROOM_reserved;
	}
	else if (strcmp(str, "check_in") == 0)
	{
		return check_in;
	}
}
```
>这类函数重复性高,本质就是通过将输入与枚举变量相比返回对应的变量
----
### 通用函数定义

由于该系统要将文本文件与代码紧密结合,因此需要多次重复从文件中读取和写入文件,就出现了下列函数,一共包括三个文本:data.txt cus_data.txt reservation.txt(稍显特殊,单独介绍)

#### data.txt
   - 读取文件
```c
TYPE_ROOM* read_from_file(const char* filename)
{
	FILE* fp;
	if ((fp = fopen(filename, "r")) == NULL)		//注意=与==的优先级，不加括号会将fopen(filename, "r") == NULL的结果赋给fp导致无法正常打开文件
	{
		printf("Failed to open the file");
		exit(0);
	}
	TYPE_ROOM* head = NULL, * tail = NULL,*curr=NULL;
	Single_room room;
	int num;
	float size;
	char _typename[100];
	int ID;
	double price;
	char status[20];
	char location[20];
	while (fscanf(fp, "%d,%f,%[^,],%d,%lf,%[^,],%[^,\n]\n", &num, &size, _typename, &ID, &price, status, location) == 7)			//%[^,] 意为自由读取直到遇到','(不读取逗号)  然后跳过逗号  [^,\n]因为在读取最后一个数时会读入\n，也要跳过
	{	
		if (curr==NULL||curr->num != num || curr->size != size || strcmp(curr->typename, _typename) != 0)							//curr==NULL判断是否为头节点,不判断的话将导致后续调用NULL访问权限冲突
		{
			TYPE_ROOM* new = (TYPE_ROOM*)malloc(sizeof(TYPE_ROOM));
			new->num = num;
			new->size = size;
			strcpy(new->typename, _typename);
			new->room = NULL;
			new->next = NULL;
			if (head == NULL)
			{
				head = new;
			}
			else
			{
				tail->next = new;
			}
			tail = new;
			curr = new;
		}
		curr->room=single_connect(curr->room, ID, price, status, location);
	}
	fclose(fp);
	return head;
}
```

- 写入文件
```c
void write_to_file(TYPE_ROOM* head,const char* filename)
{
	TYPE_ROOM* curr = head;
	FILE* fp = fopen(filename, "w");		//只写模式
	if (fp == NULL)
	{
		printf("Open failed\n");
		return;		//void型return后不加0
	}
	while (curr)
	{
		Single_room* roomcurr = curr->room;
		while (roomcurr)
		{
			fprintf(fp, "%d,%.2f,%s,%d,%.2lf,%s,%s\n",
				curr->num,
				curr->size,
				curr->typename,
				roomcurr->ID,
				roomcurr->price, 
				reconvert[3](roomcurr->status),
				reconvert[0](roomcurr->location));
			roomcurr = roomcurr->next;
		}
		
		curr = curr->next;
	}
	fclose(fp);
}
```

#### cus_data.txt
- 读取文件
```c 
CUSTOMER* read_from_cusdatafile(const char* filename)
{
	FILE* fp;
	if ((fp = fopen(filename, "r")) == NULL)		//注意=与==的优先级，不加括号会将fopen(filename, "r") == NULL的结果赋给fp导致无法正常打开文件
	{
		printf("Failed to open the file");
		exit(0);
	}
	CUSTOMER* head = NULL, * tail = NULL;
	int number;
	char ID[20];
	char name[20];
	char vip_level[20];
	while (fscanf(fp, "%d,%[^,],%[^,],%[^,\n]", &number, ID, name, vip_level) == 4)			//%[^,] 意为自由读取直到遇到','(不读取逗号)  然后跳过逗号  [^,\n]因为在读取最后一个数时会读入\n，也要跳过
	{
		CUSTOMER* new = (CUSTOMER*)malloc(sizeof(CUSTOMER));
		new->number = number;
		strcpy(new->ID, ID);
		strcpy(new->name, name);
		new->vip_level = convert[1](vip_level);
		if (head == NULL)
		{
			head = new;
			head->next = NULL;
			tail = new;
		}
		else
		{
			tail->next = new;
			tail = new;
		}
	}
	tail->next = NULL;
	fclose(fp);
	return head;
}
```
- 写入文件
```c
void write_to_cusdatafile(CUSTOMER* head, const char* filename)
{
	CUSTOMER* curr = head;
	FILE* fp = fopen(filename, "w");		//只写模式
	if (fp == NULL)
	{
		printf("Open failed\n");
		return;		//void型return后不加0
	}
	while (curr)
	{
		fprintf(fp, "%d,%s,%s,%s\n",
			curr->number,
			curr->ID,
			curr->name,
			reconvert[1](curr->vip_level));
		curr = curr->next;
	}
	fclose(fp);
}
```
>编写的思路都一样,唯一不同的是TYPE_ROOM内层还有一个链表,需要大套小
---
### 枚举变量转换为字符串

存储在结构体的枚举变量以整型变量形式存在,这样不方便也不能直观的写入文件中,因此要编写一系列函数,将枚举变量转换为字符串

- 房间位置
```c
char*  reconvert_location(enum LOCATION type)
{
	if (type == 0)
	{
		return "north";
	}
	else if (type == 1)
	{
		return "south";
	}
	else if (type == 2)
	{
		return "near_lift";
	}
	else if (type == 3)
	{
		return "near_corner";
	}
}
```
- VIP等级
```c
char* reconvert_vip_level(enum VIP_LEVEL type)
{
	if (type == 0)
	{
		return "black";
	}
	else if (type == 1)
	{
		return "gold";
	}
	else if (type == 2)
	{
		return "silver";
	}
	else if (type == 3)
	{
		return "common";
	}
}
```
- 房间位置
```c
char*  reconvert_location(enum LOCATION type)
{
	if (type == 0)
	{
		return "north";
	}
	else if (type == 1)
	{
		return "south";
	}
	else if (type == 2)
	{
		return "near_lift";
	}
	else if (type == 3)
	{
		return "near_corner";
	}
}
```
- 客人状态
```c
char* reconvert_status_cus(enum STATUS_CUS type)
{
	if (type == 0)
	{
		return "CUS_available";
	}
	else if (type == 1)
	{
		return "CUS_reserved";
	}
	else if (type == 2)
	{
		return "living";
	}
	else if (type == 3)
	{
		return "leave";
	}
}
```
- 房间状态
```c
char* reconvert_status_room(enum STATUS_ROOM type)
{
	if (type == 0)
		return "ROOM_available";
	else if (type == 1)
		return "ROOM_reserved";
	else if (type == 2)
		return "check_in";
}
```

### 管理员代前台

在该系统中还有一个结构体,该结构体命名为Reservation,专用于前台,但是在管理员中同样需要使用,使用的方法与之前大差不差,从文件中读取,写入文件等等,具体实现如下

- 读取文件
```c
Reservation* read_from_reservation(char *filename)
{
	FILE* fp = fopen(filename, "r");
	if (fp == NULL)
	{
		printf("出错啦!\n");
		return NULL;
	}
	Reservation* head = NULL,*tail=NULL,*curr=NULL;
	int reservation_id;
	char guest_id[19];
	int room_id;
	char check_in[100];
	char check_out[100];
	char status[20];
	while (fscanf(fp, "%d,%[^,],%d,%[^,],%[^,],%[^,\n]", &reservation_id, guest_id, &room_id, check_in, check_out, status)==6)
	{
		Reservation* new = (Reservation*)malloc(sizeof(Reservation));
		new->reservation_id = reservation_id;
		strcpy(new->guest_id, guest_id);
		new->room_id = room_id;
		new->check_in = string_to_time(check_in);
		new->check_out = string_to_time(check_out);
		new->status = convert_status_cus(status);
		new->next = NULL;
		if (head == NULL)
		{
			head = new;
		}
		else
		{
			tail->next = new;
		}
		tail = new;
	}
	fclose(fp);
	return head;
}
```
>该结构体中使用了time_t这一系统定义的时间类型(本质为longlong),存放一个时间戳,将其转换为具体格式需要使用一些库函数
- 写入文件
```c
void write_to_reservation(Reservation* head,const char* filename)
{
	Reservation* curr = head;
	FILE* fp = fopen(filename, "w");
	if (fp == NULL)
	{
		printf("Open failed\n");
		return;		//void型return后不加0
	}
	char t1[100];
	char t2[100];
	while (curr)
	{
		struct tm* check_in = localtime(&curr->check_in);
		struct tm* check_out = localtime(&curr->check_out);
		strftime(t1, sizeof(t1), "%Y-%m-%d %H:%M:%S", check_in);
		strftime(t2, sizeof(t2), "%Y-%m-%d %H:%M:%S", check_out);
		fprintf(fp, "%d,%s,%d,%s,%s,%s",
			curr->reservation_id, curr->guest_id, curr->room_id, t1, t2,
			reconvert_status_cus(curr->status));
		curr = curr->next;
	}
	fclose(fp);
}
```
>strftime函数,将时间戳转换为固定格式的字符串,方便写入文件

- 字符串转时间戳
```c
time_t string_to_time(char* str)
{
	struct tm tm = { 0 };
	int year = 0, month = 0, mday = 0, hour = 0, min = 0, sec = 0;
	if (sscanf(str, "%d-%d-%d %d:%d:%d",
		&year, &month, &mday, &hour, &min, &sec) != 6) {
		fprintf(stderr, "时间格式错误: %s\n", str);			//标准错误流
		return;
	}
	tm.tm_year = year-1900;
	tm.tm_mon = month-1;
	tm.tm_mday = mday;
	tm.tm_hour = hour;
	tm.tm_min = min;
	tm.tm_sec = sec;
	time_t t = mktime(&tm);
	return t;
}
```
>sscanf函数,以固定格式读取并存放到不同变量中,这里是通过中间结构体tm,将字符串中的时间替换到tm结构体中,再利用库函数mktime转换为时间戳

- 时间戳转字符串
```c
char* time_to_string(time_t t)
{
	char t1[100];
	struct tm* t2 = localtime(&t);
	strftime(t1, sizeof(t1), "%Y-%m-%d %H:%M:%S", t2);
	return t1;
}
```
>系统有专门处理这一问题的函数,localtime,传入时间戳地址,返回一个tm时间结构体,再利用strftime将tm中的数据存放到字符串中
----


### 便捷操作

文件中有多个需要重复使用的变量或者函数,因此采用头文件中声明,源文件中定义以实现全局变量的效果,以方便每一次的调用

- 文件名
```c
const char* data_filename;
const char* cus_data_filename;
const char* reservation_filename;	
const char* member_filename;
```
>头文件中声明
```c
const char* data_filename = "D:\\code\\vs2022\\c语言实验设计\\data.txt";
const char* cus_data_filename = "D:\\code\\vs2022\\c语言实验设计\\cus_data.txt";
const char* reservation_filename = "D:\\code\\vs2022\\c语言实验设计\\reservation.txt";
const char* member_filename = "D:\\code\\vs2022\\c语言实验设计\\manager.txt";
```
>任选一源文件定义

这样便能在所有文件中直接使用变量名用以代替一大长串字符串

- 函数
```c
typedef int(*CONVERT)(char* str);
typedef char* (*RECONVERT)(int);
```
>重新命名函数,一种是传入一个字符串作为形参转换为整型(枚举变量本质是int整型),一种是传入一个整型作为形参转换为字符串

```c
CONVERT convert[] = {
	(CONVERT)convert_location,
	(CONVERT)convert_vip_level,
	(CONVERT)convert_status_cus,
	(CONVERT)convert_status_room,
};													//函数指针数组，方便调用字符串转枚举型的四个函数

RECONVERT reconvert[] = {
	(RECONVERT)reconvert_location,
	(RECONVERT)reconvert_vip_level,
	(RECONVERT)reconvert_status_cus,
	(RECONVERT)reconvert_status_room,
};
```
>由于这个函数指针数组并未声明为全局变量,因此它只能在定义的源文件中使用,好在编译器会自动检查输入字符并给出可能使用到的变量,也很方便

<details>
<summary><mark><font color=darkred>点击查看详细内容</font></mark></summary>
</details>

打印函数